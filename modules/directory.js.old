const fs = require('fs');
const path = require('path');
const logger = require('./logger');
const rclone = require('./rclone');
const { getFreeSpace } = require('./disk');
const { releaseExistsInArchive, getOldestRelease } = require('./utils');

/**
 * Free up space in the specified section.
 * @param {Object} section - Incoming section details.
 * @param {Number} freeSpaceLimit - The free space limit in GB.
 * @returns {Boolean} - Whether space was freed.
 */
const freeUpSpace = async (section, freeSpaceLimit) => {
  try {
    const freeSpace = await getFreeSpace(section.device);

    if (freeSpace > freeSpaceLimit) {
      logger.log(
        `Free space (${freeSpace} GB) is above the limit (${freeSpaceLimit} GB).`,
        'info'
      );
      return false;
    }

    logger.log(
      `Free space on ${section.path} is below the limit (${freeSpace} GB < ${freeSpaceLimit} GB). Finding oldest release...`,
      'info'
    );

    // Get the oldest directory
    const oldestDir = await getOldestRelease(section.path, section.dated);
    if (!oldestDir) {
      logger.log(`No directories found to free space in section ${section.path}.`, 'info');
      return false;
    }

    logger.log(
      `Oldest release to manage: ${oldestDir.path} (Size: ${oldestDir.size || 'Unknown'} MB)`,
      'info'
    );

    // Find corresponding archive section
    const archiveSection = global.archiveSections.find(
      (a) => a.section === section.section
    );
    if (!archiveSection) {
      logger.log(
        `No archive section configured for section: ${section.section}. Cannot move to archive.`,
        'error'
      );
      return false;
    }

    const archivePath = path.join(archiveSection.path, oldestDir.name);

    // Check if the release exists in the archive
    const exists = await releaseExistsInArchive(archiveSection.path, oldestDir.name);
    if (exists) {
      logger.log(`Release ${oldestDir.name} already exists in archive (${archivePath}). Skipping.`, 'info');
      return false;
    }

    // Check free space on the archive path now
    const archiveFreeSpace = await getFreeSpace(archiveSection.device);
    logger.log(
      `Free space on archive path (${archivePath}): ${archiveFreeSpace} GB.`,
      'info'
    );

    if (archiveFreeSpace < freeSpaceLimit) {
      logger.log(
        `Insufficient space on archive path (${archivePath}). Required: ${freeSpaceLimit} GB, Available: ${archiveFreeSpace} GB.`,
        'warn'
      );
      return false;
    }

    logger.log(`Archiving ${oldestDir.path} to ${archivePath}...`, 'info');
    if (!config.debug) {
      try {
        await rclone.rcloneSync(oldestDir.path, archivePath);
        await rclone.setTimestamp(archivePath, oldestDir.mtime.getTime() / 1000);
        logger.log(`Successfully archived ${oldestDir.path} to ${archivePath}.`, 'info');
      } catch (err) {
        logger.log(
          `Error during rclone operation from ${oldestDir.path} to ${archivePath}: ${err.message}`,
          'error'
        );
        return false;
      }
    } else {
      logger.log(
        `DEBUG: Would archive ${oldestDir.path} to ${archivePath}`,
        'debug'
      );
    }

    // Delete the source directory after successful move
    logger.log(`Deleting source directory: ${oldestDir.path}...`, 'info');
    if (!config.debug) {
      try {
        fs.rmSync(oldestDir.path, { recursive: true, force: true });
        logger.log(`Successfully deleted source directory: ${oldestDir.path}.`, 'info');
      } catch (err) {
        logger.log(
          `Error deleting source directory ${oldestDir.path}: ${err.message}`,
          'error'
        );
        return false;
      }
    } else {
      logger.log(`DEBUG: Would delete ${oldestDir.path}`, 'debug');
    }

    return true;
  } catch (error) {
    logger.log(`Error freeing up space in section ${section.path}: ${error.message}`, 'error');
    return false;
  }
};

module.exports = { freeUpSpace };
